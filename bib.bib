@inproceedings{10.1145/1086365.1086390,
author = {Kiselyov, Oleg and Shan, Chung-chieh and Friedman, Daniel P. and Sabry, Amr},
title = {Backtracking, interleaving, and terminating monad transformers: (functional pearl)},
year = {2005},
isbn = {1595930647},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1086365.1086390},
doi = {10.1145/1086365.1086390},
abstract = {We design and implement a library for adding backtracking computations to any Haskell monad. Inspired by logic programming, our library provides, in addition to the operations required by the MonadPlus interface, constructs for fair disjunctions, fair conjunctions, conditionals, pruning, and an expressive top-level interface. Implementing these additional constructs is easy in models of backtracking based on streams, but not known to be possible in continuation-based models. We show that all these additional constructs can be generically and monadically realized using a single primitive msplit. We present two implementations of the library: one using success and failure continuations; and the other using control operators for manipulating delimited continuations.},
booktitle = {Proceedings of the Tenth ACM SIGPLAN International Conference on Functional Programming},
pages = {192–203},
numpages = {12},
keywords = {streams, logic programming, control delimiters, continuations, Prolog, Haskell},
location = {Tallinn, Estonia},
series = {ICFP '05}
}

@article{10.1145/1090189.1086390,
author = {Kiselyov, Oleg and Shan, Chung-chieh and Friedman, Daniel P. and Sabry, Amr},
title = {Backtracking, interleaving, and terminating monad transformers: (functional pearl)},
year = {2005},
issue_date = {September 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1090189.1086390},
doi = {10.1145/1090189.1086390},
abstract = {We design and implement a library for adding backtracking computations to any Haskell monad. Inspired by logic programming, our library provides, in addition to the operations required by the MonadPlus interface, constructs for fair disjunctions, fair conjunctions, conditionals, pruning, and an expressive top-level interface. Implementing these additional constructs is easy in models of backtracking based on streams, but not known to be possible in continuation-based models. We show that all these additional constructs can be generically and monadically realized using a single primitive msplit. We present two implementations of the library: one using success and failure continuations; and the other using control operators for manipulating delimited continuations.},
journal = {SIGPLAN Not.},
month = sep,
pages = {192–203},
numpages = {12},
keywords = {streams, logic programming, control delimiters, continuations, Prolog, Haskell}
}

@article{sozeau:hal-02167423,
  TITLE = {{The MetaCoq Project}},
  AUTHOR = {Sozeau, Matthieu and Anand, Abhishek and Boulier, Simon and Cohen, Cyril and Forster, Yannick and Kunze, Fabian and Malecha, Gregory and Tabareau, Nicolas and Winterhalter, Th{\'e}o},
  URL = {https://inria.hal.science/hal-02167423},
  JOURNAL = {{Journal of Automated Reasoning}},
  PUBLISHER = {{Springer Verlag}},
  YEAR = {2020},
  MONTH = Feb,
  DOI = {10.1007/s10817-019-09540-0},
  PDF = {https://inria.hal.science/hal-02167423v1/file/The_MetaCoq_Project.pdf},
  HAL_ID = {hal-02167423},
  HAL_VERSION = {v1},
}

@inproceedings{10.1145/53990.54010,
author = {Pfenning, F. and Elliott, C.},
title = {Higher-order abstract syntax},
year = {1988},
isbn = {0897912691},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/53990.54010},
doi = {10.1145/53990.54010},
abstract = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
booktitle = {Proceedings of the ACM SIGPLAN 1988 Conference on Programming Language Design and Implementation},
pages = {199–208},
numpages = {10},
location = {Atlanta, Georgia, USA},
series = {PLDI '88}
}

@article{10.1145/960116.54010,
author = {Pfenning, F. and Elliott, C.},
title = {Higher-order abstract syntax},
year = {1988},
issue_date = {July 1988},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {7},
issn = {0362-1340},
url = {https://doi.org/10.1145/960116.54010},
doi = {10.1145/960116.54010},
abstract = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
journal = {SIGPLAN Not.},
month = jun,
pages = {199–208},
numpages = {10}
}

@article{miller:hal-01884210,
  TITLE = {{Mechanized metatheory revisited}},
  AUTHOR = {Miller, Dale},
  URL = {https://inria.hal.science/hal-01884210},
  JOURNAL = {{Journal of Automated Reasoning}},
  PUBLISHER = {{Springer Verlag}},
  VOLUME = {63},
  NUMBER = {3},
  PAGES = {625-665},
  YEAR = {2019},
  MONTH = Oct,
  DOI = {10.1007/s10817-018-9483-3},
  KEYWORDS = {Mobility of binders ; $\lambda$ Tree syntax ; Mechanized metatheory},
  PDF = {https://inria.hal.science/hal-01884210v1/file/paper.pdf},
  HAL_ID = {hal-01884210},
  HAL_VERSION = {v1},
}

@InProceedings{10.1007/978-3-031-57262-3_10,
author="Cohen, Cyril
and Crance, Enzo
and Mahboubi, Assia",
editor="Weirich, Stephanie",
title="Trocq: Proof Transfer for Free, With or Without Univalence",
booktitle="Programming Languages and Systems",
year="2024",
publisher="Springer Nature Switzerland",
address="Cham",
pages="239--268",
abstract="This article presents Trocq, a new proof transfer framework for dependent type theory. Trocq is based on a novel formulation of type equivalence, used to generalize the univalent parametricity translation. This framework takes care of avoiding dependency on the axiom of univalence when possible, and may be used with more relations than just equivalences. We have implemented a corresponding plugin for the Coq interactive theorem prover, in the Coq-Elpi meta-language.",
isbn="978-3-031-57262-3"
}
@inproceedings{DBLP:conf/cpp/Blot0CPKMV23,
  author       = {Valentin Blot and
                  Denis Cousineau and
                  Enzo Crance and
                  Louise Dubois de Prisque and
                  Chantal Keller and
                  Assia Mahboubi and
                  Pierre Vial},
  editor       = {Robbert Krebbers and
                  Dmitriy Traytel and
                  Brigitte Pientka and
                  Steve Zdancewic},
  title        = {Compositional Pre-processing for Automated Reasoning in Dependent
                  Type Theory},
  booktitle    = {Proceedings of the 12th {ACM} {SIGPLAN} International Conference on
                  Certified Programs and Proofs, {CPP} 2023, Boston, MA, USA, January
                  16-17, 2023},
  pages        = {63--77},
  publisher    = {{ACM}},
  year         = {2023},
  url          = {https://doi.org/10.1145/3573105.3575676},
  doi          = {10.1145/3573105.3575676},
  timestamp    = {Tue, 07 Mar 2023 15:01:48 +0100},
  biburl       = {https://dblp.org/rec/conf/cpp/Blot0CPKMV23.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}
@InProceedings{cohen_et_al:LIPIcs.FSCD.2020.34,
  author =	{Cohen, Cyril and Sakaguchi, Kazuhiko and Tassi, Enrico},
  title =	{{Hierarchy Builder: Algebraic hierarchies Made Easy in Coq with Elpi}},
  booktitle =	{5th International Conference on Formal Structures for Computation and Deduction (FSCD 2020)},
  pages =	{34:1--34:21},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-155-9},
  ISSN =	{1868-8969},
  year =	{2020},
  volume =	{167},
  editor =	{Ariola, Zena M.},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2020.34},
  URN =		{urn:nbn:de:0030-drops-123562},
  doi =		{10.4230/LIPIcs.FSCD.2020.34},
  annote =	{Keywords: Algebraic Hierarchy, Packed Classes, Coq, Elpi, Metaprogramming, \lambdaProlog},
keywords = "inria:paper, inria:proud",
}

@inproceedings{affeldt:hal-03463762,
  TITLE = {{Porting the Mathematical Components library to Hierarchy Builder}},
  AUTHOR = {Affeldt, Reynald and Allamigeon, Xavier and Bertot, Yves and Canu, Quentin and Cohen, Cyril and Roux, Pierre and Sakaguchi, Kazuhiko and Tassi, Enrico and Th{\'e}ry, Laurent and Trunov, Anton},
  URL = {https://hal.science/hal-03463762},
  BOOKTITLE = {{the COQ Workshop 2021}},
  ADDRESS = {virtuel- Rome, Italy},
  YEAR = {2021},
  MONTH = Jul,
  KEYWORDS = {COQ ; HIERARCHY BUILDER},
  PDF = {https://hal.science/hal-03463762/file/DTIS21240.pdf},
  HAL_ID = {hal-03463762},
  HAL_VERSION = {v1},
keywords = "inria:workshop",

}
@inproceedings{tassi:hal-01897468,
  TITLE = {{Deriving proved equality tests in Coq-elpi: Stronger induction principles for containers in Coq}},
  AUTHOR = {Tassi, Enrico},
  URL = {https://inria.hal.science/hal-01897468},
  BOOKTITLE = {{ITP 2019 - 10th International Conference on Interactive Theorem Proving}},
  ADDRESS = {Portland, OR, United States},
  YEAR = {2019},
  MONTH = Sep,
  DOI = {10.4230/LIPIcs.CVIT.2016.23},
  KEYWORDS = {Induction ; Coq ; Equality test ; Parametricity translation ; Containers},
  PDF = {https://inria.hal.science/hal-01897468v2/file/induction.pdf},
  HAL_ID = {hal-01897468},
  HAL_VERSION = {v2},
keywords = "inria:paper",

}
@inproceedings{gregoire:hal-03800154,
  TITLE = {{Practical and sound equality tests, automatically -- Deriving eqType instances for Jasmin's data types with Coq-Elpi}},
  AUTHOR = {Gr{\'e}goire, Benjamin and L{\'e}chenet, Jean-Christophe and Tassi, Enrico},
  URL = {https://inria.hal.science/hal-03800154},
  BOOKTITLE = {{CPP '23: 12th ACM SIGPLAN International Conference on Certified Programs and Proofs}},
  ADDRESS = {Boston, MA, USA},
  PUBLISHER = {{ACM}},
  SERIES = {CPP 2023: Proceedings of the 12th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  PAGES = {167-181},
  YEAR = {2023},
  MONTH = Jan,
  DOI = {10.1145/3573105.3575683},
  PDF = {https://inria.hal.science/hal-03800154/file/feqb.pdf},
  HAL_ID = {hal-03800154},
  HAL_VERSION = {v1},
keywords = "inria:paper",

}
@InProceedings{sakaguchi:LIPIcs.ITP.2022.29,
  author =	{Sakaguchi, Kazuhiko},
  title =	{{Reflexive Tactics for Algebra, Revisited}},
  booktitle =	{13th International Conference on Interactive Theorem Proving (ITP 2022)},
  pages =	{29:1--29:22},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-252-5},
  ISSN =	{1868-8969},
  year =	{2022},
  volume =	{237},
  editor =	{Andronick, June and de Moura, Leonardo},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ITP.2022.29},
  URN =		{urn:nbn:de:0030-drops-167385},
  doi =		{10.4230/LIPIcs.ITP.2022.29},
  annote =	{Keywords: Coq, Elpi, \lambdaProlog, Mathematical Components, algebraic structures, packed classes, canonical structures, proof by reflection}
}
@inproceedings{10.5555/1765236.1765246,
author = {Delahaye, David},
title = {A tactic language for the system Coq},
year = {2000},
isbn = {3540412859},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We propose a new tactic language for the system Coq, which is intended to enrich the current tactic combinators (tacticals). This language is based on a functional core with recursors and matching operators for Coq terms but also for proof contexts. It can be used directly in proof scripts or in toplevel definitions (tactic definitions). We show that the implementation of this language involves considerable changes in the interpretation of proof scripts, essentially due to the matching operators. We give some examples which solve small proof parts locally and some others which deal with non-trivial problems. Finally, we discuss the status of this meta-language with respect to the Coq language and the implementation language of Coq.},
booktitle = {Proceedings of the 7th International Conference on Logic for Programming and Automated Reasoning},
pages = {85–95},
numpages = {11},
location = {Reunion Island, France},
series = {LPAR'00}
}
@article{10.1145/3236773,
author = {Kaiser, Jan-Oliver and Ziliani, Beta and Krebbers, Robbert and R\'{e}gis-Gianas, Yann and Dreyer, Derek},
title = {Mtac2: typed tactics for backward reasoning in Coq},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236773},
doi = {10.1145/3236773},
abstract = {Coq supports a range of built-in tactics, which are engineered primarily to support backward reasoning. Starting from a desired goal, the Coq programmer can use these tactics to manipulate the proof state interactively, applying axioms or lemmas to break the goal into subgoals until all subgoals have been solved. Additionally, it provides support for tactic programming via OCaml and Ltac, so that users can roll their own custom proof automation routines. Unfortunately, though, these tactic languages share a significant weakness. They do not offer the tactic programmer any static guarantees about the soundness of their custom tactics, making large tactic developments difficult to maintain. To address this limitation, Ziliani et al. previously proposed Mtac, a new typed approach to custom proof automation in Coq which provides the static guarantees that OCaml and Ltac are missing. However, despite its name, Mtac is really more of a metaprogramming language than it is a full-blown tactic language: it misses an essential feature of tactic programming, namely the ability to directly manipulate Coq’s proof state and perform backward reasoning on it. In this paper, we present Mtac2, a next-generation version of Mtac that combines its support for typed metaprogramming with additional support for the programming of backward-reasoning tactics in the style of Ltac. In so doing, Mtac2 introduces a novel feature in tactic programming languages—what we call typed backward reasoning. With this feature, Mtac2 is capable of statically ruling out several classes of errors that would otherwise remain undetected at tactic definition time. We demonstrate the utility of Mtac2’s typed tactics by porting several tactics from a large Coq development, the Iris Proof Mode, from Ltac to Mtac2.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {78},
numpages = {31},
keywords = {Theorem Proving, Tactic Languages, Metaprogramming, Dependent Types, Coq}
}
@inproceedings{10.1145/3354166.3354177,
author = {G\'{e}rard, Ulysse and Miller, Dale and Scherer, Gabriel},
title = {Functional programming with $\lambda$-tree syntax},
year = {2019},
isbn = {9781450372497},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3354166.3354177},
doi = {10.1145/3354166.3354177},
abstract = {We present the design of a new functional programming language, MLTS, that uses the $\lambda$-tree syntax approach to encoding bindings appearing within data structures. In this approach, bindings never become free nor escape their scope: instead, binders in data structures are permitted to move to binders within programs. The design of MLTS includes additional sites within programs that directly support this movement of bindings. In order to formally define the language's operational semantics, we present an abstract syntax for MLTS and a natural semantics for its evaluation. We shall view such natural semantics as a logical theory within a rich logic that includes both nominal abstraction and the ∇-quantifier: as a result, the natural semantics specification of MLTS can be given a succinct and elegant presentation. We present a typing discipline that naturally extends the typing of core ML programs and we illustrate the features of MLTS by presenting several examples. An on-line interpreter for MLTS is briefly described.},
booktitle = {Proceedings of the 21st International Symposium on Principles and Practice of Declarative Programming},
articleno = {12},
numpages = {16},
location = {Porto, Portugal},
series = {PPDP '19}
}
@article{TASSI_2019,
  title     = {Implementing type theory in higher order constraint logic programming},
  author    = {Guidi, Ferruccio and Coen, Claudio Sacerdoti and Tassi, Enrico},
  journal   = {Mathematical Structures in Computer Science},
  volume    = {29},
  number    = {8},
  pages     = {1125--1150},
  year      = {2019},
  publisher = {Cambridge University Press},
  DOI={10.1017/S0960129518000427},
keywords = "inria:journal",
}
@InProceedings{dunchev15lpar,
  author =       "Cvetan Dunchev and Ferruccio Guidi and Claudio
                 Sacerdoti Coen and Enrico Tassi",
  title =        "{ELPI:} Fast, Embeddable, $\lambda${Prolog}
                 Interpreter",
  booktitle =    "Logic for Programming, Artificial Intelligence, and
                 Reasoning - 20th International Conference, {LPAR-20}
                 2015, Suva, Fiji, November 24-28, 2015, Proceedings",
  editor =       "Martin Davis and Ansgar Fehnker and Annabelle McIver
                 and Andrei Voronkov",
  publisher =    pub-sv,
  series =       lncs,
  volume =       "9450",
  pages =        "460--468",
  year =         "2015",
  URL =          "https://inria.hal.science/hal-01176856v1",
  doi =          "10.1007/978-3-662-48899-7\_32",
  keywords = "inria:paper, inria:proud",

}
@inproceedings{tassi:hal-01637063,
  TITLE = {{Elpi: an extension language for Coq (Metaprogramming Coq in the Elpi $\lambda$Prolog dialect)}},
  AUTHOR = {Tassi, Enrico},
  URL = {https://inria.hal.science/hal-01637063},
  BOOKTITLE = {{The Fourth International Workshop on Coq for Programming Languages}},
  ADDRESS = {Los Angeles, CA, United States},
  YEAR = {2018},
  MONTH = Jan,
  KEYWORDS = {Coq ; $\lambda$Prolog ; metaprogramming ; extension language},
  PDF = {https://inria.hal.science/hal-01637063/file/coqpl2018.pdf},
  HAL_ID = {hal-01637063},
  HAL_VERSION = {v1},
  keywords = "inria:workshop",

}
